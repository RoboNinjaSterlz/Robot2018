// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2016.robot2018.commands;

import edu.wpi.first.wpilibj.command.CommandGroup;

import org.usfirst.frc2016.robot2018.Robot;
import org.usfirst.frc2016.robot2018.subsystems.*;

/**
 *
 */
public class AutoStartCenter extends CommandGroup {


    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PARAMETERS
    public AutoStartCenter() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PARAMETERS
        // Add Commands here:
        // e.g. addSequential(new Command1());
        //      addSequential(new Command2());
        // these will run in order.

        // To run multiple commands at the same time,
        // use addParallel()
        // e.g. addParallel(new Command1());
        //      addSequential(new Command2());
        // Command1 and Command2 will run in parallel.

        // A command group will require all of the subsystems that each member
        // would require.
        // e.g. if Command1 requires chassis, and Command2 requires arm,
        // a CommandGroup containing them would require both the chassis and the
        // arm.
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
        addSequential(new ResetGyro());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
        boolean useOldMethods = true;
        if (useOldMethods) {
	    	addParallel(new ArmHigh());
	        addSequential(new DelaySeconds(.01));
	        addSequential(new GetGameData());
	        addSequential(new TestArcDrive(-82, -52));
	        addSequential(new TestArcDrive(-52, -82));
	        addSequential(new PlaceCube());
	        addSequential(new DelaySeconds(.25));
	        addParallel(new ArmFloor());
	        addSequential(new MagicDrive(0, 39, 0));
	       // addParallel(new OpenArm());
	        addSequential(new TestArcDrive(46, 145));
	     /*   addSequential(new CloseArm());
	        addParallel(new AcquireCube());
	        addParallel(new ArmHigh());
	        addSequential(new TestArcDrive(-46, -145));
	        addSequential(new MagicDrive(0, -42, 0));
	        addSequential(new PlaceCube());
	        addSequential(new TestArcDrive(70, 23));
	        addSequential(new MagicDrive(0, 36, 0));
        */
        }
        else
        {
        	int defmoveEndLimit = 40; // ~325 counts/in : old setting 40 ~ 1/8";
        	int defcruiseVel = 1720;   // old setting 1720
        	int defaccel = 1640;      // old setting 1640
        	int moveEndLimit = 150; // ~325 counts/in : old setting 40 ~ 1/8";
        	int cruiseVel = 3000;   // old setting 1720
        	int accel = 3000;      // old setting 1640
 
        	double centerOffset = 39;
	        double centerMoveLeft = 46;
	        double centerMoveRight = 145;
	        // differnet distances to center for left/right
	        if (Robot.gameData == 'L') {
	        	// cube stack offset to right, left move should be longer
	        	centerMoveLeft += 4;
	        	centerMoveRight += 4;
	        }
	        
	    	addParallel(new ArmHigh());
	        addSequential(new GetGameData());
	        
	        // s curve for first placment
	        addSequential(new TestArcDrive(-82, -52));
	        addSequential(new TestArcDrive(-52, -82));
	        addSequential(new PlaceCube());
	        
	        // move forward to get even with the cubes
	        addParallel(new ArmFloor());
	        addSequential(new TestArcDrive(centerOffset, centerOffset, true, accel, cruiseVel, moveEndLimit));
	        
	        // arc to center cube
	        addParallel(new OpenArm());
        	addSequential(new TestArcDrive(centerMoveLeft, centerMoveRight, false, accel, cruiseVel, moveEndLimit));
	        	
	        // grab the cube
        	addSequential(new CloseArm());
	        
	        // arc back to switch
	        addParallel(new AcquireCube());
	        addSequential(new DelaySeconds(.25));
	        addParallel(new ArmHigh());
	        addSequential(new TestArcDrive(-centerMoveLeft, -centerMoveRight, false, accel, cruiseVel, moveEndLimit));
	        
	        // move back to switch & place
	        addSequential(new TestArcDrive(-centerOffset-2, -centerOffset-2, false, accel, cruiseVel, moveEndLimit));
	        addSequential(new PlaceCube());
	        
	        // arc out and down filed
	        addSequential(new TestArcDrive(70, 23, true, accel, cruiseVel, moveEndLimit));
	        addSequential(new TestArcDrive(36, 36, false, accel, cruiseVel, moveEndLimit));        	
        }
    } 
}
