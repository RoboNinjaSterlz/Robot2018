// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2016.robot2018.commands;

import edu.wpi.first.wpilibj.command.CommandGroup;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Objects;

import org.usfirst.frc2016.robot2018.Robot;

/**
 *
 */
public class DriveUsingFile extends CommandGroup {
	private String moveFileName = "centermove";    /** Default: centermove_L.csv */
	
	private String moveFilePath = "/c";				/** Default: /c folder. */
	//++private String moveFilePath= "..\\robot2018\\trunk\\";
	private final String leftName = "L";
	private final String rightName = "R";
	
	public Double secondsPerExecute = .02;
	
	public Double velocityLimit = 20.0;
	public Double accelLimit = 10.0;
	public Double distanceLimit = 150.0;
	
	public long startNanoTime; // nanoseconds
	public double moveStartTime;  // seconds

	
	private ArrayList<AutoSegment> moveList;
	private Integer moveListIndex;
	private MotorPosition posLeft;
	private MotorPosition posRight;
	
	double coastVel = 100;
	double arcVel = 10;
	double accel = 200;
	double tankWidth = 26;
	double arcRadius = 30;


	private Boolean failed = false;
	private Boolean finished = false;
	
	private enum AutoCmd {
		NOT_FOUND ("NotFound", 0),
		COAST_VEL ("CoastVel", 1),
		ARC_VEL   ("ArcVel", 1),
		ARC_RADIUS("ArcRadius", 1),
		TANK_WIDTH ("TankWidth", 1),
		ACCEL     ("Accel", 1),
		ZERO_POS  ("ZeroPos", 0), 
		MOVE      ("Move", 2), 
		ARC       ("Arc", 3), 
		JOG_MOVE  ("JogMove", 3), 
		DELAY     ("Delay", 1), 
		ARMS_CLOSE ("ArmsClose", 1), 
		ARMS_OPEN  ("ArmsOpen", 1), 
		CUBE_IN   ("CubeIn", 1), 
		CUBE_OUT  ("CubeOut", 1), 
		CUBE_STOP ("CubeStop", 1), 
		LIFT_FLOOR ("LiftFloor", 1), 
		LIFT_HIGH  ("LiftHigh", 1), 
		LIFT_FRONT  ("LiftFront", 1),
		STOP 		("Stop", 0);
		
		private final String name;
		private final int argCount;
		
		AutoCmd(String desc, int count){
			name = desc;
			argCount = count;
		}
		public String toString() { return name; }
		public int argCount() { return argCount; }
	}
	
	
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public DriveUsingFile() {
 		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrainSRX);
        requires(Robot.cubePickup);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		posLeft = new MotorPosition(leftName, 0);
		posRight = new MotorPosition(rightName, 0);
		moveList = new ArrayList<AutoSegment>();
	}

	// Called just before this Command runs the first time
	@Override
	protected void initialize() {
		//--String mySwitch = "L";
		GetGameData getGameData = new GetGameData();
		getGameData.execute();
		String mySwitch = Character.toString(Robot.gameData);
		
		resetEncoders();
		
		String filePath = moveFilePath + "/" + moveFileName + "_" + mySwitch + ".csv" ;
		Robot.telem.saveTrace("DriveUsingFile: INFO: Loading points from file [" + filePath + "]");
		//System.out.println("DriveUsingFile: INFO: Loading points from file [" + filePath + "]");
		//System.out.println("Working Directory1 = " + System.getProperty("user.dir"));
		finished = false;
		failed = false;
		startNanoTime = System.nanoTime();
		coastVel = 100;
		arcVel = 10;
		accel = 200;
		tankWidth = 26;
		arcRadius = 30;
		
		try{
			double seqeunceTime = 0;
			posLeft = new MotorPosition(leftName, seqeunceTime);
			posRight = new MotorPosition(rightName, seqeunceTime);
			moveList = new ArrayList<AutoSegment>();
			moveList.add(new AutoSegment(-1, 0.0, AutoCmd.ZERO_POS, "Init: ZeroPos()", posLeft, posRight));
			
			String fileLine;
			Integer lineNumber = 0;
			BufferedReader in = new BufferedReader(new FileReader(filePath));
			
			String msg;
			
			while (!failed && (fileLine = in.readLine()) != null) {
				lineNumber++;
				fileLine = fileLine.trim();
				if(fileLine.length() == 0 || fileLine.charAt(0) == '/')
					continue;
				
				fileLine = fileLine.trim();
				int argOpen = fileLine.indexOf('(');
				int argClose = fileLine.lastIndexOf(')');
				if (argOpen < 0 || argClose < 0 || argClose < argOpen)
				{
					System.out.println("DriveUsingFile: ****ERROR Line " + lineNumber.toString() + " is missing argument list:  cmd(arg1,...)");
					failed=true;					
					break;
				}
				String cmdName = fileLine.substring(0, argOpen);
				AutoCmd cmd = AutoCmd.NOT_FOUND;
				for(AutoCmd cmdFind : AutoCmd.values())	{
					if (Objects.equals(cmdName,cmdFind.toString())) {
						cmd = cmdFind;
						break;
					}
				}
				if(cmd==AutoCmd.NOT_FOUND)
				{
					System.out.println("DriveUsingFile: ****ERROR Line " + lineNumber.toString() + " command '" + cmdName + "' not found");
					failed=true;	
					break;
				}
				
				String argString = fileLine.substring(argOpen+1, argClose);
				String[] argList = argString.split(",");
				
				for (int argIndex=0; argIndex < argList.length; argIndex++){
					argList[argIndex] = argList[argIndex].trim();
				}
								
				msg = String.format("%.3f %d: %s( %s )", seqeunceTime, lineNumber, cmd.toString(), String.join(", ", argList));
				System.out.println(msg);
				
				if (argList.length < cmd.argCount()) {
					System.out.println("DriveUsingFile: ****ERROR Line " + lineNumber.toString() + " command needs " + cmd.argCount() + " args");
					failed=true;
					break;
				}

				switch(cmd)
				{
				case COAST_VEL:
					coastVel = Double.parseDouble(argList[0]);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
					
				case ARC_VEL:
					arcVel = Double.parseDouble(argList[0]);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
					
				case ARC_RADIUS:
					arcRadius = Double.parseDouble(argList[0]);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
					
				case TANK_WIDTH:
					tankWidth = Double.parseDouble(argList[0]);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
					
				case ACCEL:
					accel = Double.parseDouble(argList[0]);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
					
				case ZERO_POS:
					posLeft = new MotorPosition(leftName, seqeunceTime);
					posRight = new MotorPosition(rightName, seqeunceTime);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
					
				case MOVE:	{
					double deltaPos = Double.parseDouble(argList[0]);
					Boolean stopMove = Boolean.parseBoolean(argList[1]);
					
					double endVel = stopMove ? 0 : coastVel;
					double timeL = posLeft.addTarget(seqeunceTime, accel, coastVel, endVel, deltaPos);
					double timeR = posRight.addTarget(seqeunceTime, accel, coastVel, endVel, deltaPos);
					if (timeL < 0 || timeR < 0)
						failed = true;
					
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					seqeunceTime += Math.max(timeL, timeR);
					break;
				}
				
				case JOG_MOVE: {
					double deltaPos = Double.parseDouble(argList[0]);
					double sideDelta = Double.parseDouble(argList[1]);
					Boolean stopMove = Boolean.parseBoolean(argList[2]);
					double endVel = stopMove ? 0 : coastVel;
					double time = addJogMove(seqeunceTime, deltaPos, sideDelta, endVel);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					seqeunceTime += time;
					break;
				}
					
				case ARC: {
					double leftDelta = Double.parseDouble(argList[0]);
					double rightDelta = Double.parseDouble(argList[1]);
					Boolean stopMove = Boolean.parseBoolean(argList[2]);
					double endVel = stopMove ? 0 : coastVel;

					double lenL = Math.abs(leftDelta);
					double lenR = Math.abs(rightDelta);
					double time1 = 0;
					double time2 = 0;
					if (lenL < lenR) {
						// right side is longer 
						time1 = posRight.addTargetByVelocity(seqeunceTime, accel, endVel, rightDelta/2);
						time2 = posRight.addTargetByVelocity(seqeunceTime + time1, accel, endVel, rightDelta/2);
						posLeft.addTargetByTime(seqeunceTime, accel, time1, leftDelta/2);
						posLeft.addTargetByTime(seqeunceTime + time1, accel, time2, leftDelta/2);
						
					} else {
						// left side is longer
						time1 = posLeft.addTargetByVelocity(seqeunceTime, accel, endVel, leftDelta/2);
						time2 = posLeft.addTargetByVelocity(seqeunceTime + time1, accel, endVel, leftDelta/2);
						posRight.addTargetByTime(seqeunceTime, accel, time1, rightDelta/2);
						posRight.addTargetByTime(seqeunceTime + time1, accel, time2, rightDelta/2);
					}

					if (time1 < 0 || time1 < 0)
						failed = true;
					
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					seqeunceTime += time1 + time2;
					break;
				}
					
				case DELAY: {
					double sec = Double.parseDouble(argList[0]);
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					seqeunceTime += sec;
					break;
				}
				case LIFT_FRONT:
				case LIFT_HIGH:
				case LIFT_FLOOR:
				case ARMS_CLOSE:
				case ARMS_OPEN:
				case CUBE_IN:
				case CUBE_OUT:
				case CUBE_STOP: {
					double timeOffset = Double.parseDouble(argList[0]);
					if (timeOffset >= 0) {
						// timeOffset > 0 implies a delay...
						seqeunceTime += timeOffset;						
						moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					}
					else {
						// timeOffset < 0 is overlapped operation, locate insertion spot
						double insertionTime = Math.max(.001, seqeunceTime + timeOffset);
						int insertIndex = moveList.size()-1;
						for(; insertIndex > 0;  insertIndex--) {
							if(moveList.get(insertIndex).time < insertionTime) {
								insertIndex++;
								break;
							}
						}
						
						// insert or add as appropriate
						AutoSegment as = new AutoSegment(lineNumber, insertionTime, cmd, fileLine, posLeft, posRight);
						if (insertIndex < moveList.size()) {
							moveList.add(insertIndex, as);
						}
						else {
							moveList.add(as);
						}
					}
					break;
				}
				
				case STOP: {
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					failed = true;
					break;	
				}
					
				default:
					moveList.add(new AutoSegment(lineNumber, seqeunceTime, cmd, fileLine, posLeft, posRight));
					break;
				}
				
				

			}
			in.close();
			
			moveList.add(new AutoSegment(99999, seqeunceTime, AutoCmd.STOP , "End: Stop()", posLeft, posRight));
			
			msg = String.format("Sequence time %.2f", seqeunceTime);
			System.out.println(msg);
			
		} catch (IOException e) {
			System.out.println("DriveUsingFile(): ****ERROR: Failed to load the file " + this.moveFileName  + 
					"   Exception:" + e + "  Reason:" + e.getMessage() );
			failed = true;
		}


		finished = false;
		failed = false;
		moveListIndex = 0;
		startNanoTime = System.nanoTime() - 1;
		
		processCommands(0.0);
	}
	
	protected double addJogMove(double seqeunceTime, double deltaPos, double jogDelta, double endVel) {
		double moveLen = Math.abs(deltaPos);
		double moveDir = (deltaPos > 0) ? 1 : -1;
		
		double jogLen = Math.abs(jogDelta);
		
		double shortLen = 0.5 * (moveLen - jogLen);
		if (shortLen < 0) {
			System.out.println("JogMove(): ****ERROR: offset length must be less than total move length" );
			failed = true;
			return -1;
		}
		double longLen = 0.5 * (moveLen + jogLen);
		double lenRatio = shortLen / longLen;
		
		double launchTime = coastVel / accel;
		
		double launchLongAccel = accel;
		double launchLongLen = 0.5 * launchLongAccel * launchTime * launchTime;
		
		double launchShortAccel = launchLongAccel * lenRatio;
		double launchShortLen = 0.5 * launchShortAccel * launchTime * launchTime;
		launchShortLen = launchLongLen * lenRatio;
		
		double coastLongVel = coastVel;
		double coastShortVel = launchShortAccel * launchTime;
		coastShortVel = coastVel * lenRatio;
		
		double swapAccel = accel; 
		double swapTime = (coastLongVel - coastShortVel) / swapAccel; 
		double swapLen = swapTime * 0.5 * (coastShortVel + coastLongVel);
		
		double coastTotalLen = moveLen - launchLongLen - swapLen - launchShortLen;
		double coastLongLen = coastTotalLen / (1 + lenRatio);
		double coastShortLen = coastLongLen * lenRatio;
		
		if (coastLongLen < 0 || coastShortLen < 0) 	{
			System.out.println("JogMove(): ****ERROR: move too short or delta too big to perform" );
			failed = true;
			return -1;
		}

		double coastTime = coastLongLen / coastLongVel;
		coastTime = coastShortLen / coastShortVel;
		
		double moveTime = 2 * (launchTime + coastTime) + swapTime;
		
		MotorPosition s2 = jogDelta > 0 ? posLeft : posRight;
		MotorPosition s1 = jogDelta > 0 ? posRight: posLeft;
		
		MovePoint ptLast1 = s1.getLastEnd(seqeunceTime);
		MovePoint ptLast2 = s2.getLastEnd(seqeunceTime);
		
		double targetPos1 = ptLast1.pos + deltaPos;
		double targetPos2 = ptLast2.pos + deltaPos;
		
		// accel both sides to target velocities
		ptLast1 = s1.addMoveSegment("launch" , ptLast1, moveDir * launchLongAccel, launchTime);
		ptLast2 = s2.addMoveSegment("launch" , ptLast2, moveDir * launchShortAccel, launchTime);
		
		// coast
		ptLast1 = s1.addMoveSegment("coast" , ptLast1, 0, coastTime);
		ptLast2 = s2.addMoveSegment("coast" , ptLast2, 0, coastTime);
		
		// swap velocities 
		ptLast1 = s1.addMoveSegment("swap" , ptLast1, -moveDir * swapAccel, swapTime);
		ptLast2 = s2.addMoveSegment("swap" , ptLast2, moveDir * swapAccel, swapTime);
		
		// coast
		ptLast1 = s1.addMoveSegment("coast" , ptLast1, 0, coastTime);
		ptLast2 = s2.addMoveSegment("coast" , ptLast2, 0, coastTime);
		
		// brake
		ptLast1 = s1.addMoveSegment("brake" , ptLast1, -moveDir * launchShortAccel, launchTime);
		ptLast2 = s2.addMoveSegment("brake" , ptLast2, -moveDir * launchLongAccel, launchTime);
		
		double time1 = s1.checkMoveTarget(ptLast1, targetPos1, moveTime);
		double time2 = s2.checkMoveTarget(ptLast2, targetPos2, moveTime);

		if (time1 < 0 || time2 < 0) {
			System.out.println("JogMove(): ****ERROR: target distance mismatch" );
			failed = true;
			return -1;			
		}
			
		return moveTime;
	}
	
	// Called repeatedly when this Command is scheduled to run
	@Override
	protected void execute() {
		Double seqeunceTime = (double)(System.nanoTime() - startNanoTime) / 1e9;
		
		processCommands(seqeunceTime);
		updateDriveTrain(seqeunceTime);
		
		//++String msg = String.format("%7.3f %s %s", seqeunceTime, posLeft.toString(), posRight.toString());
		//Robot.telem.saveTrace( msg );
		//++System.out.println(msg);

	}

	// Make this return true when this Command no longer needs to run execute()
	@Override
	protected boolean isFinished() {
		return (failed || finished);
	}

	// Called once after isFinished returns true
	@Override
	protected void end() {
		shutdown();
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	@Override
	protected void interrupted() {
		shutdown();
	}
	
	private void shutdown()
	{
		finished = true;
		failed = true;
		Robot.cubePickup.autoEnd();
		Robot.driveTrainSRX.driveStop();
	}

	private void updateDriveTrain(double seqeunceTime)
	{
		double leftDistance = posLeft.updatePosition(seqeunceTime);
		double rightDistance = posRight.updatePosition(seqeunceTime);
		if (!failed)
		{
			Robot.driveTrainSRX.goToDistance(leftDistance, rightDistance);
		}
		Robot.driveTrainSRX.pingDifferentialDrive();
	}
	
	private void resetEncoders() {
		for(int i=0; i < 100; i++) {
		Robot.driveTrainSRX.resetEncoders();
		double posLeft = Robot.driveTrainSRX.getLeftDistance();
		double posRight = Robot.driveTrainSRX.getRightDistance();
		if (Math.abs(posLeft) < .001 && Math.abs(posRight) < .001) {
				System.out.println("DriveUsingFile: encoders zeroed " + i);
				break;
			}
		}
	}
	
	private void executeZeroPos(AutoSegment autoSeg)
	{
		posLeft = autoSeg.posLeft;
		posRight = autoSeg.posRight;
	
		resetEncoders();
		//++posLeft.start(100);
		//++posRight.start(100);
		posLeft.start(Robot.driveTrainSRX.getLeftDistance());
		posRight.start(Robot.driveTrainSRX.getRightDistance());
	}

	private void processCommands(double timeNow) {
		
		while(moveListIndex < moveList.size()) {
			AutoSegment autoSeg = moveList.get(moveListIndex);
			if (autoSeg.time > timeNow) {
				break;
			}
			moveListIndex++;
			String msg = String.format(">> %.2f %2d: %s", timeNow, autoSeg.lineNumber, autoSeg.fileLine);
			Robot.telem.saveTrace(msg);
			//-System.out.println(msg);
					
		
			switch(autoSeg.command)
			{
			default:
				System.out.println("processCommands: " + autoSeg.command.name() + " not handled");
				break;
				
			case COAST_VEL:
			case ARC_VEL:
			case TANK_WIDTH:
			case ACCEL:
			case MOVE:
			case JOG_MOVE:
			case ARC:
			case DELAY:
				break;
				
			case ZERO_POS:
				executeZeroPos(autoSeg);
				break;
				
			case ARMS_CLOSE:
				Robot.cubePickup.closeArms();
				break;
				
			case ARMS_OPEN:
				Robot.cubePickup.openArms();
				break;
				
			case CUBE_IN:
				Robot.cubePickup.acquireCube();
				break;
				
			case CUBE_OUT:
				Robot.cubePickup.autoEjectCube();
				break;
				
			case CUBE_STOP:
				Robot.cubePickup.autoEnd();
				break;
				
			case LIFT_FLOOR:
				Robot.arm.goToPreset(Robot.arm.FLOOR);
				break;
				
			case LIFT_HIGH:
				Robot.arm.goToPreset(Robot.arm.HIGH);
				break;
			
			case LIFT_FRONT:
				Robot.arm.goToPreset(Robot.arm.MEDIUM);
				break;
				
			case STOP:
				moveListIndex = moveList.size();
				break;
			}
			
		}
		finished = moveListIndex >= moveList.size();
	}


	// helper class to contain the parsed command file information
	public class AutoSegment {
		public int lineNumber;
		public String fileLine;
		public double time;
		public AutoCmd command;
		public MotorPosition posLeft; 
		public MotorPosition posRight; 
		
		public AutoSegment(int lineCount, double t, AutoCmd cmd, String lineData, MotorPosition left, MotorPosition right)
		{
			lineNumber = lineCount;
			fileLine = lineData;
			time = t; 
			command = cmd;
			posLeft = left;
			posRight = right;
		}

	}

	// Move profiles for a single motor
	public class MotorPosition
	{
		//private final double minMoveTime = 0.001;
		private String name;
		private ArrayList<MoveSegment> moveSegmentList;
		private MovePoint ptLast;
		private double offsetPos;
		private int moveSegmentIndex;
		private double minMoveValue = .05;
		
		public MotorPosition(String motorName, double startTime)
		{
			name = motorName;
			ptLast = new MovePoint();
			ptLast.time = startTime;

			moveSegmentList = new ArrayList<MoveSegment>();
			
			MoveSegment msInit = new MoveSegment();
			msInit.accel = 0;
			msInit.ptStart.set(ptLast);
			msInit.ptEnd.set(ptLast);
			
			moveSegmentList.add(new MoveSegment());
			start(0);
		}

		public double getDistance()
		{
			return ptLast.pos + offsetPos;
		}
		
		public double getOffset() {
			return offsetPos;
		}
		
		public double updatePosition(double sequenceTime) {
			MoveSegment moveSeq = null;
			
			// advance segment if needed
			while(moveSegmentIndex < moveSegmentList.size()) {
				moveSeq = moveSegmentList.get(moveSegmentIndex);
				if (moveSeq.ptEnd.time > sequenceTime) {
					break;
				}
				moveSegmentIndex++;
			}
			
			// calculate location within segment
			if (moveSeq != null) {
				MovePoint pt = moveSeq.getPoint(sequenceTime);
				ptLast.set(pt);				
			}
			
			return getDistance();
		}
		
		public String toString()
		{
			double accel = 0;
			String desc = "-";
			if (moveSegmentIndex < moveSegmentList.size()) {
				MoveSegment ms = moveSegmentList.get(moveSegmentIndex);
				accel = ms.accel;
				desc = ms.desc.substring(0, 1);
				
			}
			return String.format(" %s%s:%2d %7.1f %7.1f %7.1f %7.1f", name, desc, moveSegmentIndex, accel, ptLast.vel, ptLast.pos, getDistance());
		}
		
		public void start(double offset) {
			offsetPos = offset;
			moveSegmentIndex = 0;
			MoveSegment ms = moveSegmentList.get(moveSegmentIndex);
			ptLast.set(ms.ptStart);
		}
		
		protected double moveLength(double accel, double time)  {
			 return 0.5 * accel * time * time;
		}
		
		protected double moveLength(double accel, double vel, double time)  {
			 return vel * time + 0.5 * accel * time * time;
		}
		
		protected MovePoint getLastEnd(double startTime) {
			MovePoint ptLastEnd = moveSegmentList.get(moveSegmentList.size()-1).ptEnd;
			startTime = Math.max(startTime,  ptLastEnd.time);
			
			if (ptLastEnd.time < startTime) {
				// need a filler segment for the time gap
				ptLastEnd = addMoveSegment("fill", ptLastEnd, 0, startTime - ptLastEnd.time);
			}
			return ptLastEnd;
		}
		
		public double getLastVelocity() {
			return moveSegmentList.get(moveSegmentList.size()-1).ptEnd.vel;
		}
		
		public double checkMoveTarget(MovePoint ptLastEnd, double targetPos, double moveTime) {
			
			// sanity check for the profile generation
			if (Math.abs(targetPos - ptLastEnd.pos) > minMoveValue) {
				String msg = String.format("Move path error: move end should be %.2f, path at %.2f", targetPos, ptLastEnd.pos);
				System.out.println(msg);
				moveTime = -1; // error return
			}
			
			// remove small roundoff errors 
			ptLastEnd.pos = targetPos;		
			return moveTime;			
		}
		
		public double addTargetByVelocity(double startTime, double maxAccel, double maxVel, double deltaPos) {
			// ignore a zero length move
			if (Math.abs(deltaPos) < minMoveValue) return 0;
			
			// get the last segment
			MovePoint ptLastEnd = getLastEnd(startTime);
			
			// calc the move parameters
			double endVel = (deltaPos > 0) ? maxVel : -maxVel;
			double targetPos = ptLastEnd.pos + deltaPos;
			double moveTime = 2 * deltaPos / (ptLastEnd.vel + endVel);
			double moveAccel = (endVel - ptLastEnd.vel) / moveTime;
			
			if (Math.abs(moveAccel) > maxAccel) {
				String msg = String.format("Move path error: move accel (%.0f) exceeds max accel (%.0f)", Math.abs(moveAccel), maxAccel);
				System.out.println(msg);
				return -1; // error return
			}
			
			ptLastEnd = addMoveSegment("vel", ptLastEnd, moveAccel, moveTime);
			
			return checkMoveTarget(ptLastEnd, targetPos, moveTime);
		}
		
		public double addTargetByTime(double startTime, double maxAccel, double moveTime, double deltaPos) {
			// ignore a zero length move
			if (Math.abs(deltaPos) < minMoveValue) return 0;
			
			if (moveTime < minMoveValue) {
				System.out.println("addTargetByTime: Move path error: move time too small");
				return -1; // error return
			}
			
			// get the last segment
			MovePoint ptLastEnd = getLastEnd(startTime);
			
			// calculate the move parameters
			double targetPos = ptLastEnd.pos + deltaPos;
			double targetVel = 2 * deltaPos / moveTime - ptLastEnd.vel;
			double moveAccel = (targetVel - ptLastEnd.vel) / moveTime;
			
			if (Math.abs(moveAccel) > maxAccel) {
				String msg = String.format("Move path error: move accel (%f) exceeds max accel (%f)", Math.abs(moveAccel), maxAccel);
				System.out.println(msg);
				return -1; // error return
			}
			
			// add the segment
			ptLastEnd = addMoveSegment("time", ptLastEnd, moveAccel, moveTime);
			
			return checkMoveTarget(ptLastEnd, targetPos, moveTime);
		}	
		
		public double addTarget(double startTime, double maxAccel, double coastVel, double endVel, double deltaPos) {
			// ignore a zero length move
			if (Math.abs(deltaPos) < minMoveValue) return 0;
			
			// get the last segment
			MovePoint ptLastEnd = getLastEnd(startTime);
			
			// calc the move parameters
			double targetPos = ptLastEnd.pos + deltaPos;
			double moveLen = Math.abs(deltaPos);
			double moveDirection = deltaPos > 0 ? 1 : -1;
			
			double launchAccel =  moveDirection * maxAccel;
			double launchTime = Math.abs((moveDirection * coastVel - ptLastEnd.vel) / maxAccel);
			double launchLen = moveLength(maxAccel, launchTime);
			if (launchLen < minMoveValue) {
				// already moving at coastVel 
				launchAccel = 0;
				launchLen = 0;
				launchTime = 0;
			}
			launchLen += Math.abs(ptLastEnd.vel) * launchTime;
			
			double brakeAccel = -moveDirection * maxAccel;  
			double brakeTime = Math.abs((coastVel-endVel) / maxAccel);
			double brakeLen = moveLength(maxAccel, brakeTime);
			if (brakeLen < minMoveValue) {
				// move continuing with the next segment
				brakeAccel = 0;
				brakeLen = 0;
				brakeTime = 0;
			}
			brakeLen += endVel * brakeTime;
			
			double coastLen = moveLen - launchLen - brakeLen;
			double coastTime = coastLen / coastVel;
			if (coastLen > -minMoveValue) {
				// move needs a coast section 
				if (launchLen > minMoveValue) {
					// accelerate (or de-accel) to new velocity 
					ptLastEnd = addMoveSegment("launch", ptLastEnd, launchAccel, launchTime);
				}
				
				// constant velocity coast section
				if (coastLen > minMoveValue) {
					ptLastEnd = addMoveSegment("coast", ptLastEnd, 0, coastTime);
				}
					
				if (brakeLen > minMoveValue) {
					// 'brake' to end velocity
					ptLastEnd = addMoveSegment("brake", ptLastEnd, brakeAccel, brakeTime);
				}				
				
				double totalTime = launchTime + coastTime + brakeTime;
				return checkMoveTarget(ptLastEnd, targetPos, totalTime);
			}
			
			if (endVel < minMoveValue && Math.abs(ptLastEnd.vel) < minMoveValue) {
				// short move bounded by acceleration
				launchLen = moveLen / 2;
				launchTime = Math.sqrt(2 * launchLen / maxAccel);					
				brakeLen = launchLen;
				brakeTime = launchTime;				
				// accelerate (or de-accel) to new velocity 
				ptLastEnd = addMoveSegment("launch", ptLastEnd, launchAccel, launchTime);
				// 'brake' to end velocity
				ptLastEnd = addMoveSegment("brake ", ptLastEnd, brakeAccel, brakeTime);
				
				double totalTime = launchTime + brakeTime;
				return checkMoveTarget(ptLastEnd, targetPos, totalTime);
			}
			
			
			double aveVel = Math.abs(0.5 * (endVel * moveDirection + ptLastEnd.vel));
			if (aveVel > minMoveValue) {
				// 
				launchTime = Math.abs(moveLen / aveVel);
				launchAccel = (endVel - ptLastEnd.vel) / launchTime;
				
				if (Math.abs(launchAccel) > maxAccel) {
					String msg = String.format("Move path error: move accel (%f) exceeds max accel (%f)", Math.abs(launchAccel), maxAccel);
					System.out.println(msg);
					return -1; // error return
				}
				ptLastEnd = addMoveSegment("ramp", ptLastEnd, launchAccel, launchTime);
				return checkMoveTarget(ptLastEnd, targetPos, launchTime);
			}
			
			String msg = String.format("Path planning failed from %.1f to %.1f", deltaPos, targetPos);
			System.out.println(msg);
			return -1; // error return
		}
		
		public MovePoint addMoveSegment(String desc, MovePoint ptLastEnd, double accel, double segmentTime) {
			MoveSegment msNew = new MoveSegment(desc, ptLastEnd, accel, segmentTime);
			moveSegmentList.add(msNew);
			String msg = String.format("  %s %s", name, msNew.toString());
			System.out.println(msg);
			return msNew.ptEnd;
		}	
	}
	


	// Movement between two states
	public class MoveSegment {
		public String desc;
		public double accel;
		public MovePoint ptStart;
		public MovePoint ptEnd;
		public MovePoint ptLast;
		
		public MoveSegment() {
			accel = 0;
			ptStart = new MovePoint();
			ptEnd = new MovePoint();
			ptLast = new MovePoint();
		}
		
		public MoveSegment(String segmentDesc, MovePoint ptLastEnd, double segmentAccel, double segmentSeconds) {
			desc = segmentDesc;
			accel = segmentAccel;
			ptStart = new MovePoint(ptLastEnd);
			ptEnd = new MovePoint();
			ptEnd.time = ptStart.time + segmentSeconds;
			ptEnd.vel = ptStart.vel + accel * segmentSeconds;
			ptEnd.pos = ptStart.pos + ptStart.vel * segmentSeconds + 0.5 * accel * segmentSeconds * segmentSeconds;
			ptLast = new MovePoint(ptEnd);
		}	
		
		public MovePoint getPoint(double time)
		{
			if (time <= ptStart.time) {
				ptLast.set(ptStart);
			}
			else if (time >= ptEnd.time) {
				ptLast.set(ptEnd);
			}
			else {
				double dt = time - ptStart.time;
				ptLast.time = time;
				ptLast.vel = ptStart.vel + accel * dt;
				ptLast.pos = ptStart.pos + ptStart.vel * dt + 0.5 * accel * dt * dt;
			}
			return ptLast;
		}
		
		public String toString() {
			return String.format("%6.6s A:%5.0f D:%7.1f  (%s) -> (%s)", desc, accel, ptEnd.pos - ptStart.pos, ptStart.toString(), ptEnd.toString());
		}
	}
		
	// Movement state at given time
	public class MovePoint {
		public double time;
		public double vel;
		public double pos;
		
		public MovePoint() {
			time = 0;
			vel = 0;
			pos = 0;
		}
		
		public MovePoint(MovePoint pt) {
			time = pt.time;
			vel = pt.vel;
			pos = pt.pos;
		}
		
		public void set(MovePoint pt)
		{
			time = pt.time;
			vel = pt.vel;
			pos = pt.pos;
		}
		
		public String toString() {
			return String.format("T:%7.3f V:%7.1f P:%7.1f", time, vel, pos);
		}
	}
}
