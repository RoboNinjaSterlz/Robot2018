// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2016.robot2018.subsystems;

import org.usfirst.frc2016.robot2018.Defaults;
import org.usfirst.frc2016.robot2018.Robot;
import org.usfirst.frc2016.robot2018.Config;
import org.usfirst.frc2016.robot2018.RobotMap;
import org.usfirst.frc2016.robot2018.MMW_DifferentialDrive;
import org.usfirst.frc2016.robot2018.commands.*;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.MotorSafetyHelper;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.*;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
@SuppressWarnings("deprecation")
public class DriveTrainSRX extends Subsystem {
	static int finalLeft, finalRight;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX talonDriveLeft2 = RobotMap.driveTrainSRXTalonDriveLeft2;
    private final WPI_TalonSRX talonDriveLeft3 = RobotMap.driveTrainSRXTalonDriveLeft3;
    private final WPI_TalonSRX talonDriveRight2 = RobotMap.driveTrainSRXTalonDriveRight2;
    private final WPI_TalonSRX talonDriveRight3 = RobotMap.driveTrainSRXTalonDriveRight3;
	private final WPI_TalonSRX talonDriveLeft1 = RobotMap.driveTrainSRXTalonDriveLeft1;
    private final WPI_TalonSRX talonDriveRight1 = RobotMap.driveTrainSRXTalonDriveRight1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private final MMW_DifferentialDrive differentialDrive = RobotMap.driveTrainSRXDifferentialDrive;

	//    private final RobotDrive robotDrive = RobotMap.drivetrainRobotDrive;
	private final double SPEED_P = .15;
	private final double SPEED_I = .05;
	private final double speedFeedForward = .6;
	private final double COUNTS_PER_INCH = 4096/12.57;  //Encoder counts / inch of travel
	
	
	// parameters for determining when move is completed
	private final int MAX_POSITION_ERROR = 40;
	private final int STUCK_ENCODER_LIMIT = 10; // counts changing less than limit are considered 'stuck'
	private final int STUCK_MAX_COUNT =  20; // number of periodic scans before indicating 'stuck'
    private final int STUCK_START_IGNORE = 25; // number of periodic scans before detecting 'stuck'
    
    private final int pidSlot0 = 0;
    private final int timeoutMs = 0;
    
	/*
	 * The following block of variables are used to hold values loaded from
	 * NV RAM by RobotPrefs.
	 */
	public double drivetrainVoltageLimit;
	public double rampIncrement;
	public double driveP;
	public double driveI;
	public double driveD;
	public double driveF;
	public int cruiseVelocity;
	public int acceleration;
	public boolean joySquare;
	/*
	 * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	 * End of values set by RobotPrefs
	 */

	private double lastDesiredSpeed = 0;

	private double leftCurrentSpeed = 0;
	private double rightCurrentSpeed = 0;

	private double lastJoyLeft, lastJoyRight;
	private String lastDriveMode;
	private double lastRightCount, lastLeftCount, stuckCount, stuckStartCount;
	private double accumSpeed =0;
	
	private double lastEndDistanceLeft = 0;
	private double lastEndDistanceRight = 0;
	
	StringBuilder _sb = new StringBuilder();
	int _loops = 0;

	/*
	 * Magic Motion vales
	 * 
	 * Cim max no load speed 5330
	 * Cim load speed 5330 * .9 = 4797
	 * Gear box 6.66:1 
	 * 4797/6.66 = 720.2 RPMs
	 * 720.2/60 = 12.0 RPS
	 * 4096 counts/rev * 12.0 RPS = 49,152 Counts / second
	 * 49152/1000*100 = 4915.2 Revs Per 100ms
	 * SRX intrnal speed is -1023 to +1023
	 * Feed forward = 1023/4915.2 = .8333
	 * 
	 * Wheel diameter = 4 inches
	 * 4 * Pi = 12.57 inches per rev
	 * 12 inches /sec = 4096 counts/second
	 * 4096/1000 * 100 = 409.6 counts/100ms
	 * Cruise Velocity = 410
	 * 
	 * Plan on .25 seconds to accelerate and .25 to decelerate
	 * Acceleration = 205
	 */

	public DriveTrainSRX() {
		loadConfig(Robot.config);
		talonDriveLeft1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative , pidSlot0, timeoutMs);
		talonDriveLeft1.setSensorPhase(true); //!!!! Check this !!!!!
		talonDriveLeft1.setInverted(false);
		talonDriveLeft1.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
		talonDriveLeft1.configForwardLimitSwitchSource(
				LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, timeoutMs);
		talonDriveLeft1.configForwardSoftLimitEnable(false, timeoutMs);
		talonDriveLeft1.configReverseSoftLimitEnable(false, timeoutMs);
		talonDriveLeft1.clearStickyFaults(0);
		talonDriveLeft1.setIntegralAccumulator(0, pidSlot0, timeoutMs);
		talonDriveLeft1.setNeutralMode(NeutralMode.Brake);
		talonDriveLeft1.set(ControlMode.PercentOutput, 0);
		talonDriveLeft1.config_kP(pidSlot0, driveP, timeoutMs);
		talonDriveLeft1.config_kI(pidSlot0, driveI, timeoutMs);
		talonDriveLeft1.config_kD(pidSlot0, driveD, timeoutMs);
		talonDriveLeft1.config_kF(pidSlot0, driveF, timeoutMs);
		talonDriveLeft1.setSelectedSensorPosition(0, pidSlot0, timeoutMs);

		// talonDriveLeft1.setSafetyEnabled(false);

		talonDriveLeft2.setInverted(false);
		talonDriveLeft2.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
		talonDriveLeft2.configForwardLimitSwitchSource(
				LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, timeoutMs);
		talonDriveLeft2.configForwardSoftLimitEnable(false, timeoutMs);
		talonDriveLeft2.configReverseSoftLimitEnable(false, timeoutMs);
		talonDriveLeft2.clearStickyFaults(0);
		talonDriveLeft2.setIntegralAccumulator(0, pidSlot0, timeoutMs);
		talonDriveLeft2.setNeutralMode(NeutralMode.Brake);
		talonDriveLeft2.set(ControlMode.Follower, 0);

		talonDriveLeft3.setInverted(false);
		talonDriveLeft3.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
		talonDriveLeft3.configForwardLimitSwitchSource(
				LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, timeoutMs);
		talonDriveLeft3.configForwardSoftLimitEnable(false, timeoutMs);
		talonDriveLeft3.configReverseSoftLimitEnable(false, timeoutMs);
		talonDriveLeft3.clearStickyFaults(timeoutMs);
		talonDriveLeft3.setIntegralAccumulator(0, pidSlot0, timeoutMs);
		talonDriveLeft3.setNeutralMode(NeutralMode.Brake);
		talonDriveLeft3.set(ControlMode.Follower, 0);

		talonDriveRight1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative , pidSlot0, timeoutMs);
		talonDriveRight1.setSensorPhase(true); //!!!! Check this !!!!!
		talonDriveRight1.setInverted(true);
		talonDriveRight1.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
		talonDriveRight1.configForwardLimitSwitchSource(
				LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, timeoutMs);
		talonDriveRight1.configForwardSoftLimitEnable(false, 0);
		talonDriveRight1.configReverseSoftLimitEnable(false, 0);
		talonDriveRight1.clearStickyFaults(0);
		talonDriveRight1.setIntegralAccumulator(0, pidSlot0, timeoutMs);
		talonDriveRight1.setNeutralMode(NeutralMode.Brake);
		talonDriveRight1.set(ControlMode.PercentOutput, 0);
		talonDriveRight1.config_kP(pidSlot0, driveP, timeoutMs);
		talonDriveRight1.config_kI(pidSlot0, driveI, timeoutMs);
		talonDriveRight1.config_kD(pidSlot0, driveD, timeoutMs);
		talonDriveRight1.config_kF(pidSlot0, driveF, timeoutMs);
		talonDriveRight1.setSelectedSensorPosition(0, pidSlot0, timeoutMs);
		// 	talonDriveRight1.setSafetyEnabled(false);
		talonDriveRight2.setInverted(true);
		talonDriveRight2.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
		talonDriveRight2.configForwardLimitSwitchSource(
				LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, timeoutMs);
		talonDriveRight2.configForwardSoftLimitEnable(false, 0);
		talonDriveRight2.configReverseSoftLimitEnable(false, 0);
		talonDriveRight2.clearStickyFaults(0);
		talonDriveRight2.setIntegralAccumulator(0, 0, 0);
		talonDriveRight2.setNeutralMode(NeutralMode.Brake);
		talonDriveRight2.set(ControlMode.Follower, 3);

		talonDriveRight3.setInverted(true);
		talonDriveRight3.configAllowableClosedloopError(pidSlot0, 0, timeoutMs);
		talonDriveRight3.configForwardLimitSwitchSource(
				LimitSwitchSource.FeedbackConnector,
				LimitSwitchNormal.NormallyOpen, timeoutMs);
		talonDriveRight3.configForwardSoftLimitEnable(false, timeoutMs);
		talonDriveRight3.configReverseSoftLimitEnable(false, timeoutMs);
		talonDriveRight3.clearStickyFaults(0);
		talonDriveRight3.setIntegralAccumulator(0, pidSlot0, timeoutMs);
		talonDriveRight3.setNeutralMode(NeutralMode.Brake);
		talonDriveRight3.set(ControlMode.Follower, 3);

		/*
		 * Additional settings for motion magic Left
		 */
		/* Set relevant frame periods to be at least as fast as periodic rate*/
		talonDriveLeft1.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
		talonDriveLeft1.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);

		/* set the peak and nominal outputs */
		talonDriveLeft1.configNominalOutputForward(0, 0);
		talonDriveLeft1.configNominalOutputReverse(0, 0);
		talonDriveLeft1.configPeakOutputForward(1, 0);
		talonDriveLeft1.configPeakOutputReverse(-1, 0);

		/* set acceleration and vcruise velocity - see documentation */
		talonDriveLeft1.configMotionCruiseVelocity(cruiseVelocity, 0);
		talonDriveLeft1.configMotionAcceleration(acceleration, 0);

		/*
		 * Additional settings for motion magic Right
		 */

		/* Set relevant frame periods to be at least as fast as periodic rate*/
		talonDriveRight1.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, 0);
		talonDriveRight1.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, 0);

		/* set the peak and nominal outputs */
		talonDriveRight1.configNominalOutputForward(0, 0);
		talonDriveRight1.configNominalOutputReverse(0, 0);
		talonDriveRight1.configPeakOutputForward(1, 0);
		talonDriveRight1.configPeakOutputReverse(-1, 0);

		/* set acceleration and vcruise velocity - see documentation */
		talonDriveRight1.configMotionCruiseVelocity(cruiseVelocity, 0);
		talonDriveRight1.configMotionAcceleration(acceleration, 0);
	}


	public void periodic() {
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	/**
	 * Limit motor values to the -1.0 to +1.0 range.
	 */
	protected double limit(double value) {
		if (value > 1.0) {
			return 1.0;
		}
		if (value < -1.0) {
			return -1.0;
		}
		return value;
	}

	protected double applyDeadband(double value, double deadband) {
		if (Math.abs(value) > deadband) {
			if (value > 0.0) {
				return (value - deadband) / (1.0 - deadband);
			} else {
				return (value + deadband) / (1.0 - deadband);
			}
		} else {
			return 0.0;
		}
	}

	/**
	 * Arcade drive method for differential drive platform.
	 *
	 * @param xSpeed        The robot's speed along the X axis [-1.0..1.0]. Forward is positive.
	 * @param zRotation     The robot's rotation rate around the Z axis [-1.0..1.0]. Clockwise is
	 *                      positive.
	 * @param squaredInputs If set, decreases the input sensitivity at low speeds.
	 */
	public void arcadeDriveX(double xSpeed, double zRotation, boolean squaredInputs) {
		xSpeed = limit(xSpeed);
		xSpeed = applyDeadband(xSpeed, .01);

		// Flip the sign for steering
		zRotation = -limit(zRotation);
		zRotation = applyDeadband(zRotation, .01);

		// Square the inputs (while preserving the sign) to increase fine control
		// while permitting full power.
		if (squaredInputs) {
			xSpeed = Math.copySign(xSpeed * xSpeed, xSpeed);
			zRotation = Math.copySign(zRotation * zRotation, zRotation);
		}

		double leftMotorOutput;
		double rightMotorOutput;

		double maxInput = Math.copySign(Math.max(Math.abs(xSpeed), Math.abs(zRotation)), xSpeed);

		if (xSpeed >= 0.0) {
			// First quadrant, else second quadrant
			if (zRotation >= 0.0) {
				leftMotorOutput = maxInput;
				rightMotorOutput = xSpeed - zRotation;
			} else {
				leftMotorOutput = xSpeed + zRotation;
				rightMotorOutput = maxInput;
			}
		} else {
			// Third quadrant, else fourth quadrant
			if (zRotation >= 0.0) {
				leftMotorOutput = xSpeed + zRotation;
				rightMotorOutput = maxInput;
			} else {
				leftMotorOutput = maxInput;
				rightMotorOutput = xSpeed - zRotation;
			}
		}

		differentialDrive.tankDrive(-leftMotorOutput, rightMotorOutput, false);
	}

	public void gameVelocityDrive(Joystick joy) {
		final double MAX_SPEED = 2000;
		double leftOut, rightOut;
		double rightYstick = -joy.getY();
		double motorOutput = talonDriveRight1.getMotorOutputPercent();
		/* prepare line to print */
		_sb.append("\tout:");
		_sb.append(motorOutput);
		_sb.append("\tspd:");
		_sb.append(talonDriveRight1.getSelectedSensorVelocity(0));

		if (joy.getRawButton(1)) {
			/* Speed mode */
			/* Convert 500 RPM to units / 100ms.
			 * 4096 Units/Rev * 500 RPM / 600 100ms/min in either direction:
			 * velocity setpoint is in units/100ms
			 */
			double targetVelocity_UnitsPer100ms = rightYstick * 500.0 * 4096 / 600;
			/* 500 RPM in either direction */
			talonDriveRight1.set(ControlMode.Velocity, targetVelocity_UnitsPer100ms);

			/* append more signals to print when in speed mode. */
			_sb.append("\terr:");
			_sb.append(talonDriveRight1.getClosedLoopError(0));
			_sb.append("\ttrg:");
			_sb.append(targetVelocity_UnitsPer100ms);
		} else {
			/* Percent voltage mode */
			//--SmartDashboard.putNumber("Vel Pad Y", rightYstick);
			talonDriveRight1.set(ControlMode.PercentOutput, rightYstick);

		}

		if (++_loops >= 10) {
			_loops = 0;
			System.out.println(_sb.toString());
		}
		_sb.setLength(0);
		//differentialDrive.tankDrive(0,0);

		/*
		leftOut = joy.getY()*MAX_SPEED;
		rightOut = joy.getRawAxis(5) * MAX_SPEED;
		talonDriveLeft1.set(ControlMode.Velocity, leftOut);
		talonDriveRight1.set(ControlMode.Velocity, rightOut);
		 */   
		pingDifferentialDrive();
	}

	/*
	 * Used for single joystick device using X and Y
	 */
	public void arcadeDrive(Joystick joy) {
		accumSpeed = 0;
		lastJoyLeft = joy.getY();
		lastJoyRight = joy.getX();
		//		differentialDrive.arcadeDrive(joy.getY(), joy.getX(), true);
		arcadeDriveX(joy.getY(), joy.getX(), joySquare);
		lastDriveMode = "ArcadeJoy";
	}

	/*
	 * Arcade drive using game pad axis 5 as direction
	 */
	public void arcadeDrive(Joystick leftJoy, Joystick rightJoy) {
		accumSpeed = 0;
		lastJoyRight= leftJoy.getRawAxis(5);
		lastJoyLeft = leftJoy.getY();
		// The values to pass to the motors are adjusted by the ramp method
		leftCurrentSpeed = returnRamp(leftCurrentSpeed, lastJoyLeft);
		rightCurrentSpeed = returnRamp(rightCurrentSpeed, lastJoyRight);
		//SmartDashboard.putNumber("LJoyY", lastJoyLeft);
		//SmartDashboard.putNumber("LCurrentSpeed", leftCurrentSpeed);
		//		differentialDrive.arcadeDrive(leftCurrentSpeed, rightCurrentSpeed, true);
		arcadeDriveX(leftCurrentSpeed, rightCurrentSpeed, joySquare);
		lastDriveMode = "ArcadeJoy";
	}

	/*
	 * Arcade drive using values for speed and direction
	 */
	public void arcadeDrive(double speed, double direction) {
		velocityDrive(speed, direction);
		lastJoyLeft = speed;
		lastJoyRight = direction;
		lastDriveMode = "Arcade";
	}

	/*
	 * Arcade style drive using the gyro for feed back
	 * 
	 * Special case:
	 * 	If the speed is zero, take the speed from the left joy stick.
	 */
	public void gyroDrive(double speed, double angle) {
		double steer =  (Robot.gyro.getAngle() - angle);
		if (steer > 180) {
			steer = steer - 360;
		}
		else if (steer < -180) {
			steer = steer + 360;
		}
		steer *= -Robot.gyro.gyroP;

		if (steer > Robot.gyro.gyroTurnMax) {
			steer = Robot.gyro.gyroTurnMax;
		}
		else if (steer < -Robot.gyro.gyroTurnMax) {
			steer = -Robot.gyro.gyroTurnMax;
		}
		lastDriveMode = "Gyro";
		if (speed== 0) {
			//Use the joystick or stop if centered
			//Robot.drivetrain.arcadeDrive(Robot.oi.driveRight.getY(), steer);
			//velocityDrive(Robot.oi.driveRight.getY(), steer);
			//        	robotDrive.arcadeDrive(Robot.oi.driveRight.getY(), steer);
			//			differentialDrive.arcadeDrive(Robot.oi.driveLeft.getY(), steer);
			lastJoyLeft= Robot.oi.driveLeft.getY();
			arcadeDriveX(lastJoyLeft, steer ,false);
		}
		else {
			//    		Robot.drivetrain.arcadeDrive(speed, steer);
			velocityDrive(speed, steer);
			lastJoyLeft = speed;
			lastJoyRight = steer;
		}
	}

	/*
	 * Used by other methods for sort of PID speed control 
	 */
	public void velocityDrive(double speed, double direction) {
		double rateError;
		double finalSpeed;
		double averageRate;
		finalSpeed = 0;
		speed /= 10;
		if (Math.abs(speed) < .01) speed = 0;
		if (speed==0) {
			accumSpeed = 0;
		}
		else
		{
			if (accumSpeed == 0)
			{
				accumSpeed = (speed > 0) ? speedFeedForward : -speedFeedForward;
			}

			averageRate=getAverageRate();
			rateError = speed + averageRate/300;
			accumSpeed += rateError * SPEED_I;
			if (accumSpeed > .7) {
				accumSpeed = .7;
			}
			else if (accumSpeed <-.7) {
				accumSpeed = -.7;
			}
			finalSpeed = accumSpeed + rateError * SPEED_P;
			//SmartDashboard.putNumber("rateError", rateError);
			//SmartDashboard.putNumber("accumSpeed", accumSpeed);
		}

		//		differentialDrive.arcadeDrive(finalSpeed, direction);
		arcadeDriveX(finalSpeed, direction, false);
		lastJoyLeft = finalSpeed;
		lastJoyRight = direction;
		lastDriveMode = "Velocity";
	}

	/*
	 * Method for driving a fixed distance straight
	 * This may get expanded to steer as well.
	 * For now it's a test to used motion magic to drive
	 */
	public void goToUsingMM(double speed, int distance, double direction) {
		int distanceAsCounts;

		// convert absolute distance into absolute encoder counts
		distanceAsCounts = (int)Math.round(distance * COUNTS_PER_INCH);
		
		// for now reset encoders to make debugging easier
		// May not want to do this in the final code.
		// resetEncoders();
		// resetEncoders();
		/*
		 * Get the current encoder counts and 
		 * convert distance counts to relative counts
		 * It may be better to reset the counters.
		 */
		// Dont reset the counters since it is not reliable
		finalLeft = distanceAsCounts + getLeftEncoder();
		finalRight = distanceAsCounts + getRightEncoder();
		
		// Reset the speed in case someone else changed it.
		talonDriveLeft1.configMotionCruiseVelocity(cruiseVelocity, 0);
		talonDriveRight1.configMotionCruiseVelocity(cruiseVelocity, 0);
		talonDriveLeft1.configMotionAcceleration(acceleration, 0);
		talonDriveLeft1.configMotionAcceleration(acceleration, 0);
		talonDriveLeft1.set(ControlMode.MotionMagic, finalLeft);
		talonDriveRight1.set(ControlMode.MotionMagic, finalRight);
		stuckCount = 0;
		/*
		 * Will need to disable motorSafetyHepler when not using differentialDrive Calls
		 */
		//	SmartDashboard.putNumber("FinalRight", finalRight);
		//	SmartDashboard.putNumber("Distance in Counts", distanceAsCounts);
	}

	public void goToUsingMM(double leftDistance, double rightDistance) {
		int distanceAsCountsLeft;
		int distanceAsCountsRight;
		int leftCruiseVelocity = cruiseVelocity;
		int rightCruiseVelocity = cruiseVelocity;
		int leftAccel = acceleration;
		int rightAccel = acceleration;
		double distanceRatio;

		// convert absolute distance into absolute encoder counts
		distanceAsCountsLeft = (int)Math.round(leftDistance * COUNTS_PER_INCH);
		distanceAsCountsRight = (int)Math.round(rightDistance * COUNTS_PER_INCH);

		// Don't reset the counters since it is not reliable
		finalLeft = distanceAsCountsLeft + getLeftEncoder();
		finalRight = distanceAsCountsRight + getRightEncoder();

		// Now adjust the speed for the distance difference
		distanceAsCountsLeft = Math.abs(distanceAsCountsLeft);
		distanceAsCountsRight = Math.abs(distanceAsCountsRight);
		
		if (distanceAsCountsLeft < distanceAsCountsRight)
		{
			distanceRatio = (double)distanceAsCountsLeft / (double)distanceAsCountsRight;
			leftCruiseVelocity = (int)Math.round(cruiseVelocity * distanceRatio);
			leftAccel = (int)Math.round(acceleration * distanceRatio );
		}
		else if (distanceAsCountsRight < distanceAsCountsLeft)
		{
			distanceRatio = (double)distanceAsCountsRight / (double)distanceAsCountsLeft;
			rightCruiseVelocity = (int)Math.round(cruiseVelocity * distanceRatio);
			rightAccel = (int)Math.round(acceleration * distanceRatio );
		}

		// Reset the speed in case someone else changed it.
		//SmartDashboard.putNumber("FinalRight", finalRight);
		//SmartDashboard.putNumber("Distance in Counts", distanceAsCountsRight);
		talonDriveLeft1.configMotionCruiseVelocity(leftCruiseVelocity, 0);
		talonDriveRight1.configMotionCruiseVelocity(rightCruiseVelocity, 0);
		
		talonDriveLeft1.configMotionAcceleration(leftAccel, 0);
		talonDriveRight1.configMotionAcceleration(rightAccel, 0);
		
		talonDriveLeft1.set(ControlMode.MotionMagic, finalLeft);
		talonDriveRight1.set(ControlMode.MotionMagic, finalRight);
		stuckCount = 0;
	}
	
	public void goToUsingMM(double leftDistance, double rightDistance, boolean newStart, int accel, int vel) {
		if (newStart) {
			// start move from current location
			lastEndDistanceLeft = getLeftDistance();
			lastEndDistanceRight = getRightDistance();
		}
		
		// update the last distance to include this move
		lastEndDistanceLeft += leftDistance;
		lastEndDistanceRight += rightDistance;
		
		// update the final count target for this move
		finalLeft = (int)Math.round(lastEndDistanceLeft * COUNTS_PER_INCH);
		finalRight = (int)Math.round(lastEndDistanceRight * COUNTS_PER_INCH);
		
		// get absolute magnitude of the move
		leftDistance = Math.abs(leftDistance);
		rightDistance = Math.abs(rightDistance);
		
		// check for default accel/vel
		if (accel <= 0) accel = acceleration;
		if (vel <= 0) vel = cruiseVelocity;
		
		// scale the accel/vel to match the magnitude of the moves
		int leftCruiseVelocity = vel;
		int rightCruiseVelocity = vel;
		int leftAccel = accel;
		int rightAccel = accel;
		double distanceRatio;

		if (leftDistance < rightDistance)
		{
			distanceRatio = (double)leftDistance / (double)rightDistance;
			leftCruiseVelocity = (int)Math.round(vel * distanceRatio);
			leftAccel = (int)Math.round(accel * distanceRatio );
		}
		else if (rightDistance < leftDistance)
		{
			distanceRatio = (double)rightDistance / (double)leftDistance;
			rightCruiseVelocity = (int)Math.round(vel * distanceRatio);
			rightAccel = (int)Math.round(accel * distanceRatio );
		}

		// Reset the speed in case someone else changed it.
		//SmartDashboard.putNumber("FinalRight", finalRight);
		//SmartDashboard.putNumber("Distance in Counts", distanceAsCountsRight);
		talonDriveLeft1.configMotionCruiseVelocity(leftCruiseVelocity, 0);
		talonDriveRight1.configMotionCruiseVelocity(rightCruiseVelocity, 0);
		
		talonDriveLeft1.configMotionAcceleration(leftAccel, 0);
		talonDriveRight1.configMotionAcceleration(rightAccel, 0);
		
		talonDriveLeft1.set(ControlMode.MotionMagic, finalLeft);
		talonDriveRight1.set(ControlMode.MotionMagic, finalRight);
		stuckCount = 0;
	}
	
	public void goTo(double leftDistance, double rightDistance) {
		int distanceAsCountsLeft;
		int distanceAsCountsRight;

		// convert absolute distance into absolute encoder counts
		distanceAsCountsLeft = (int)Math.round(leftDistance * COUNTS_PER_INCH);
		distanceAsCountsRight = (int)Math.round(rightDistance * COUNTS_PER_INCH);

		// Don't reset the counters since it is not reliable
		finalLeft = distanceAsCountsLeft + getLeftEncoder();
		finalRight = distanceAsCountsRight + getRightEncoder();

		talonDriveLeft1.set(ControlMode.Position, finalLeft);
		talonDriveRight1.set(ControlMode.Position, finalRight);
		stuckCount = 0;
	}

	public void goToDistance(double leftDistance, double rightDistance) {
		// convert absolute distance into absolute encoder counts
		int distanceAsCountsLeft = (int)Math.round(leftDistance * COUNTS_PER_INCH);
		int distanceAsCountsRight = (int)Math.round(rightDistance * COUNTS_PER_INCH);
		
		talonDriveLeft1.set(ControlMode.Position, distanceAsCountsLeft);
		talonDriveRight1.set(ControlMode.Position, distanceAsCountsRight);
		stuckCount = 0;
	}


	public void pingDifferentialDrive() {
		differentialDrive.pingMotorSafety();
	}

	/*
	 * Method to go with the above move used to determine
	 * when the move has completed
	 */
	public boolean moveComplete(int maxPositionError) {
		if (maxPositionError <= 0) {
			maxPositionError = MAX_POSITION_ERROR;
		}
		
		int leftEncoder =  getLeftEncoder();
		int rightEncoder = getRightEncoder();
		boolean leftGood = Math.abs(finalLeft - leftEncoder) < maxPositionError;
		boolean rightGood = Math.abs(finalRight - rightEncoder) < maxPositionError;
		
	    boolean stuck = false;
		if (stuckStartCount < STUCK_START_IGNORE) {
			stuckStartCount++;
		}
		else if (stuckCount < STUCK_MAX_COUNT) {
			stuckCount++;
			if (Math.abs(lastLeftCount - leftEncoder) > STUCK_ENCODER_LIMIT || Math.abs(lastRightCount - rightEncoder) > STUCK_ENCODER_LIMIT) {
				stuckCount = 0;
			}
		}
		else {
			stuck = true;
		}
			
		lastLeftCount = leftEncoder;
		lastRightCount = rightEncoder;
		//  SmartDashboard.putNumber("TalonDriveRight position", finalRight);
		//SmartDashboard.putBoolean("Right Good", rightGood);
		//SmartDashboard.putBoolean("Left Good", leftGood);
		//--SmartDashboard.putNumber("Left Error", finalLeft - leftEncoder);
		//--SmartDashboard.putNumber("Right Error", finalRight - rightEncoder);
		//--SmartDashboard.putBoolean("Drive Stuck", stuck);
		return stuck || (leftGood && rightGood);
	}
	
	public boolean moveComplete() {
		return moveComplete(0);
	}
	
	
	/*
	 * Returns the average encoder rate of left and right 
	 */
	public double getAverageRate() {
		double rightRate, leftRate, averageRate;

		rightRate = talonDriveRight1.getSelectedSensorVelocity(0);
		leftRate = talonDriveLeft1.getSelectedSensorVelocity(0);
		averageRate=(leftRate+rightRate)/2;
		return averageRate;
	}

	/*
	 * Tank drive using game pad where right comes from axis 5
	 */
	public void tankDrive(Joystick leftJoy, Joystick rightJoy) {
		accumSpeed = 0;
		lastJoyRight= rightJoy.getRawAxis(5);
		lastJoyLeft = leftJoy.getY();

		// The values to pass to the motors are adjusted by the ramp method
		leftCurrentSpeed = returnRamp(leftCurrentSpeed, lastJoyLeft);
		rightCurrentSpeed = returnRamp(rightCurrentSpeed, lastJoyRight);
		//SmartDashboard.putNumber("LSpeed", leftCurrentSpeed);
		//SmartDashboard.putNumber("RSpeed", rightCurrentSpeed);
		//SmartDashboard.putNumber("lastJoyLeft", lastJoyLeft);
		differentialDrive.tankDrive(-leftCurrentSpeed, rightCurrentSpeed, joySquare);
		lastDriveMode = "Tank";    	
	}	

	/*
	 * Stop the robot
	 */
	public void driveStop() {
		differentialDrive.tankDrive(0,0);
		accumSpeed = 0;
	}

	/*
	 * Set the max voltage to the drive train
	 * The joystick values will be scaled by this value
	 */
	public void setMax() {
		differentialDrive.setMaxOutput(drivetrainVoltageLimit);
	}

	// This method performs the ramp calculation for the drive train
	double returnRamp(double currentSpeed, double desiredSpeed) {
		double delta = desiredSpeed - currentSpeed;

		if (delta > rampIncrement) {
			delta = rampIncrement;
		}
		else if ( delta < - rampIncrement) {
			delta = - rampIncrement;
		}
		return (currentSpeed + delta);
	}

	public int getRightEncoder() {
		return talonDriveRight1.getSelectedSensorPosition(0);
	}

	public int getLeftEncoder() {
		return talonDriveLeft1.getSelectedSensorPosition(0);
	}

	public double getRightDistance() {
		return (double)getRightEncoder() / COUNTS_PER_INCH;
	}
	
	public double getLeftDistance()	{
		return (double)getLeftEncoder() / COUNTS_PER_INCH;
	}
	
	public int getLeftEncoderVelocity() {
		return talonDriveLeft1.getSelectedSensorVelocity(0);
	}
	public int getRightEncoderVelocity() {
		return talonDriveRight1.getSelectedSensorVelocity(0);
	}

	public void resetEncoders() {
		talonDriveLeft1.setSelectedSensorPosition(0, 0, 10);
		talonDriveRight1.setSelectedSensorPosition(0, 0, 10);
	}

	public void addTelemetryHeaders() {
		Robot.currentMonitor.registerMonitorDevive(talonDriveLeft1, "Drive Left 1");
		Robot.currentMonitor.registerMonitorDevive(talonDriveLeft2, "Drive Left 2");
		Robot.currentMonitor.registerMonitorDevive(talonDriveLeft3, "Drive Left 3");
		Robot.currentMonitor.registerMonitorDevive(talonDriveRight1, "Drive Right 1");
		Robot.currentMonitor.registerMonitorDevive(talonDriveRight2, "Drive Right 2");
		Robot.currentMonitor.registerMonitorDevive(talonDriveRight3, "Drive Right 3");
		Robot.telem.addColumn("Drive Left");
		Robot.telem.addColumn("Drive Right");
		Robot.telem.addColumn("Drive Mode");
		
		Robot.telem.addColumn("Left Distance");
		Robot.telem.addColumn("Right Distance");
		
		//Robot.telem.addColumn("Left Target");
		//Robot.telem.addColumn("Right Target");
	}

	public void writeTelemetry() {
		Robot.telem.saveDouble("Drive Left", lastJoyLeft);
		Robot.telem.saveDouble("Drive Right", lastJoyRight);
		Robot.telem.saveString("Drive Mode", lastDriveMode);
		Robot.telem.saveDouble("Left Distance", getLeftDistance());
		Robot.telem.saveDouble("Right Distance", getRightDistance());
		
		//Robot.telem.saveDouble("Left Target", talonDriveLeft1.getClosedLoopTarget(0)/COUNTS_PER_INCH);
		//Robot.telem.saveDouble("Right Target", talonDriveRight1.getClosedLoopTarget(0)/COUNTS_PER_INCH);
	}

	public void loadConfig(Config config) {
		drivetrainVoltageLimit = config.getDouble("DriveVLimit", Defaults.DRIVETRAIN_VOLTAGE_LIMIT_DEFAULT);
		setMax();
		rampIncrement = config.getDouble("DriveRampIncrement", Defaults.DRIVETRAIN_RAMP_INCREMENT);
		driveP = config.getDouble("DriveP", Defaults.DRIVETRAIN_P);
		driveI = config.getDouble("DriveI", Defaults.DRIVETRAIN_I);
		driveD = config.getDouble("DriveD", Defaults.DRIVETRAIN_D);
		driveF = config.getDouble("DriveF", Defaults.DRIVETRAIN_F);
		cruiseVelocity = config.getInt("CruiseVelocity", Defaults.DRIVE_CRUISEVELOCITY);
		acceleration = config.getInt("Acceleration", Defaults.DRIVE_ACCELERATION);
		joySquare = config.getBoolean("DriveJoystickSquare", Defaults.DRIVE_JOYSQUARE);
	}
	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new GamePadDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

}

